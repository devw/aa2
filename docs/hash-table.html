<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8" />
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>Hash Table</title>
        <link rel="stylesheet" href="./main.css" />
        <link rel="stylesheet" href="./collapse.css" />
        <script src="vendors/highlight.min.js"></script>
        <script src="vendors/highlight.ln.min.js"></script>
        <link rel="stylesheet" href="vendors/highlight.min.css" />
    </head>
    <body>
        <!-- https://junminlee3.medium.com/hash-tables-animations-that-will-make-you-understand-how-they-work-d1bcc850ba71 -->
        <!-- /Users/antonio/Downloads/Lecture17.pdf -->
        <article id="introduction">
            <details>
                <summary>The Map Data Structure</summary>
                <h2>Why Hashing?</h2>
                <p>
                    Internet has grown to millions of users generating terabytes of content every day. According to internet data tracking services, the amount of content on the internet doubles every six months. With this kind of growth, it is impossible to find anything in the internet, unless we develop new data structures and algorithms for storing and accessing data. So what is wrong with traditional data structures like Arrays and Linked Lists? Suppose we have a very large data set stored in an array. The amount of time required to look up an element in the array is either O(log n) or O( n) based on whether the array is sorted or not. If the array is sorted then a technique such as binary search can be used to search the array. Otherwise, the array must be searched linearly. Either case may not be desirable if we need to process a very large data set. Therefore we discuss a new technique called hashing that allows us to update and retrieve any entry in constant time O(1). The constant time or O(1) performance means, the amount of time to perform the operation does not depend on data size n.
                </p>
                <h2>Definition</h2>
                <p>In a mathematical sense, a map is a relation between two sets. We can define Map M as a set of pairs, where each pair is of the form (key, value), where for given a key, we can find a value using some kind of a â€œfunctionâ€ that maps keys to values. The key for a given object can be calculated using a function called a hash function. In its simplest form, we can think of an array as a Map where key is the index and value is the value at that index. For example, given an array A, if i is the key, then we can find the value by simply looking up A[i]. The idea of a hash table is more generalized and can be described as follows.
                </p>
                <p>The concept of a hash table is a generalized idea of an array where key does not have to be an integer. We can have a name as a key, or for that matter any object as the key. The trick is to find a hash function to compute an index so that an object can be stored at a specific location in a table such that it can easily be found.</p>
                <var>hash: KEYS -> {0, 1, 2, ..., n - 1}</var>
                <img class="size-l" src="images/ht/brute-force.gif" alt="" />
                <h2>Example</h2>
                <p>Suppose we have a set of strings {â€œabcâ€, â€œdefâ€, â€œghiâ€} that we'd like to store in a table. Our objective here is to find or update them quickly from a table, actually in O(1). We are not concerned about ordering them or maintaining any order at all. Let us think of a simple schema to do this. Suppose we assign â€œaâ€ = 1, â€œbâ€=2, ... etc to all alphabetical characters. We can then simply compute a number for each of the strings by using the sum of the characters as follows.</p>
                <var>â€œabcâ€=1+2+3=6, â€œdefâ€=4+5+6=15 , â€œghiâ€=7+8+9=24</var>
                <p>If we assume that we have a table of size 5 to store these strings, we can compute the
                    location of the string by taking the sum mod 5. So we will then store â€œabcâ€ in 6 mod 5 = 1,â€œdefâ€ in 15 mod 5 = 0, and â€œghiâ€ in 24 mod 5 = 4 in locations 1, 0 and 4 as follows.</p>
                <pre><code class="python">
                    ["def", "abc", Null, Null, "ghi", Null]
                </code></pre>
                <h2>Hash Function Definition</h2>
                <p>
                    A hash function over a set ğ‘‹ is a function ğ» that takes an element ğ‘¥ in ğ‘‹ and associates to ğ‘¥ an
                    integer ğ» (ğ‘¥ ) in the interval [0, ğ‘€ ), for some integer ğ‘€ . In symbols
                    <pre>
                        ğ» âˆ¶ğ‘‹ â†’ [0,ğ‘€)
                    </pre>
                </p>
                <img class="size-l" src="./images/ht/hash-function.gif" alt="" />
                <img class="size-l" src="./images/ht/hash-function-module.gif" alt="" />
                <h2>hash function</h2>
                <p>
                    There are three ways of calculating the hash function:
                    <ul>
                        <li>Division method</li>
                        <li>Folding method</li>
                        <li>Mid square method</li>
                    </ul>
                </p>
                <p>In the division method, the hash function can be defined as:</p>
<pre class="math">
h(ki) = ki mod m; 
//Modulo is a math operation that finds the remainder when one integer is divided by another. 
// In writing, it is frequently abbreviated as mod, or represented by the symbol %.
//  where m is the size of the hash table.
</pre>
                    
<p>
                    For example, if the key value is 6 and the size of the hash table is 10. When we apply the hash function to key 6 then the index would be:
                </p>             
                   <var> h(6) = 6 % 10 = 6</var>
                    <p>
                    The index is 6 at which the value is stored.</p>
            </details>
        </article>
        <article id="hash-collision">
            <details>
                <summary>Problem with Hashing</summary>
                <h2>Introduction</h2>
                <p>

                    The hash function we used, that is the sum of the letters, is a bad one. In case we have permutations of the same letters, â€œabcâ€, â€œbacâ€ etc in the set, we will end up with the same value for the sum and hence the key. In this case, the strings would hash into the same location, creating what we call a â€œcollisionâ€. This is obviously not a good thing. Secondly, we need to find a good table size, preferably a prime number so that even if the sums are different, then collisions can be avoided, when we take mod of the sum to find the location. So we ask two questions.
                </p>
                <ul>
                    <li>Question 1: How do we pick a good hash function?</li>
                    <li>Question 2: How do we deal with collisions?</li>
                </ul>
                <div>
                    <h2>Hash Collission</h2>
                    <p></p>
                    <img class="size-l" src="./images/ht/hash-function-collision.gif" alt="" />
                    <p>To handle hash collisions we can use two techniques: 1) closed addressing and 2) open addressing</p>
                </div>
            </details>
        </article>
        <article id="open-addressing">
            <details>
                <summary>Open Hashing (Closed Addressing)</summary>
                <p>Open hashing is also known as closed addressing</p>
                <p>
                    The "open" in "open hashing" refers to the fact that we leave the hash table; we do not guarantee that the object is stored directly at an index in the hash table's internal array.
                </p>
                <p>
                    The "close" in "closed addressing" tells us the index (aka. address) at which an object will be stored in the hash table is completely determined by its hash code. Indeed, the object's index does not vary regardless of what's already in the hash table.
                </p>

                <div id="hashing-separate-chaining">
                    <h2>Chaining Method</h2>
                    <p>In open hashing, one of the methods used to resolve the collision is known as a chaining method</p>
                    <img class="size-l" src="./images/separate-chaining.png" alt="">
                    <img class="size-l" src="./images/ht/hash.separate-chaining.gif" alt="" />
                    <p>
                        Suppose to place the values 12, 17, 29, 33, 42 and 39 with this hash function 
                    </p>
                    <var>h (x) = (x mod 10) + 1</var>
                    <p>We will obtain the following table (the new additions are made at the beginning of the list).</p>
                    <img src="./images/hash-collision-separate-chaining.png" alt="">
                    <p class="info">The NIL value indicated above represents an empty value, it is a constant often used in Algorithms. In python it is designated as None</p>
                </div>
            </details>
        </article>
        <article id="open-addressing">
            <details>
                <summary>Closed Hashing (Open Addressing)</summary>
                <p>Closed Hashing is also known as open addressing</p>
                <div>
                    <h2>Hashing with Open Addressing</h2>
                    <p>The open addressing is a technique for collision resolution.</p>
                    <p>The open addressing technique ensures that the data always remains within the same vector.</p>
                    <p>
                        It inserts the data into the hash table itself. The size of the hash table should be larger than
                        the number of keys.
                    </p>
                    <p>
                        The "open" in "open addressing" tells us the index (aka. address) at which an object will be stored in the hash table is not completely determined by its hash code. Instead, the index may vary depending on what's already in the hash table.
                    </p>
                    <p>
                        The "closed" in "closed hashing" refers to the fact that we never leave the hash table; every object is stored directly at an index in the hash table's internal array. Note that this is only possible by using some sort of open addressing strategy. This explains why "closed hashing" and "open addressing" are synonyms.
                    </p>
                </div>
                <div>
                    <h2>Handling Overflow with Linear Probing</h2>
                    <img class="size-l" src="./images/ht/hash-open.addressing.gif" alt="" />
                </div>
                <div>
                    <h2>Handling Overflow with Re-Hashing (Double Hashing)</h2>
                    <img src="./images/overflow-area.gif" alt="">
                </div>

            </details>
        </article>
        <!-- 1573625332.pdf -->
        <!-- <article><details><summary>Practice Problems on Hashing</summary>
            <h2></h2>
            <ul>
                <li>What are the advantages and disadvantages of hash tables compared to binary search trees?</li>
            </ul>
        </details></article> -->
    </body>
    <script>
        hljs.highlightAll();
    </script>
</html>

<!-- http://www.btechsmartclass.com/data_structures/tree-terminology.html -->

